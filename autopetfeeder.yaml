esphome:
  name: autopetfeeder
  friendly_name: autopetfeeder

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "GENERATED_BY_ESPHOME"

ota:
  password: "GENERATED_BY_ESPHOME"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    # Set this to the IP of the ESP
    static_ip: 192.168.0.88
    # Set this to the IP address of the router. Often ends with .1
    gateway: 192.168.0.1
    # The subnet of the network. 255.255.255.0 works for most home networks.
    subnet: 255.255.255.0

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Autopetfeeder Fallback Hotspot"
    password: "GENERATED_BY_ESPHOME"

captive_portal:
    
deep_sleep:
  id: deep_sleep_1
  run_duration: 
    default: 120s
    gpio_wakeup_reason: 30s
  wakeup_pin_mode: 
    KEEP_AWAKE 
  sleep_duration: 1440min  # cannot omit 
  wakeup_pin: GPIO4
  #wakeup_pin_mode: INVERT_WAKEUP

sensor:
  - platform: ultrasonic
    trigger_pin: GPIO3
    echo_pin: GPIO5
    update_interval: 3s
    name: "Ultrasonic Sensor"
    id: distance
    timeout: 4m
    force_update: false
    filters:
      lambda: if (isnan(x)) { return 999.0; } return x;
  - platform: homeassistant 
    entity_id: sensor.autopetfeeder_ultrasonic_sensor
    id: ultrasonic_distance
    internal: true   
  - platform: adc
    pin: GPIO2 # D0 
    name: "autopetfeeder"
    raw: true 
    attenuation: 11dB
    update_interval: 10s    
    filters:
      - multiply: 0.0014652014652015  
#      - sliding_window_moving_average:
#          window_size: 60
#          send_every: 60

binary_sensor:
  - platform: gpio
    pin: GPIO4
    name: "PIR Sensor"
    device_class: motion

#display:
#    platform: tm1637
#    id: tm1637_display
#    clk_pin: GPIO7
#    dio_pin: GPIO6
#    inverted: false
#    intensity: 2
#    length: 4
#    lambda: |-
#      it.printf(0,"%03.2f", id(ultrasonic_distance).state);

globals:
- id: cover_nomovement_count 
  type: int 
  initial_value: "0" 
- id: cover_status
  type: int 
  initial_value: "0"

interval:
  - interval: 1s
    then: 
      - lambda: |-
          if(id(distance).state < 0.8 && id(cover_status) == 0) {
            id(my_cover).open(); 
            id(cover_status) = 1; 
            id(cover_nomovement_count) = 0; 
          } else {
            if(id(distance).state >= 0.8 && id(cover_status) == 1) {
              id(cover_nomovement_count) = id(cover_nomovement_count) + 1; 
              ESP_LOGD("lambda", "nomovement %d", id(cover_nomovement_count));  
            } else { 
              id(cover_nomovement_count) = 0;
            }
            
            if(id(cover_nomovement_count) > 45) {
              id(cover_nomovement_count) = 0;
              id(cover_status) = 0;               
              id(my_cover).close(); 
            }
          }
          

output:
  - platform: ledc
    id: motor_forward_pin
    pin: GPIO9 
  - platform: ledc
    id: motor_reverse_pin
    pin: GPIO8 
  - platform: ledc 
    id: motor_enable 
    pin: GPIO10
  - platform: ledc
    pin: GPIO20
    id: gpio_d7    

light:
  - platform: monochromatic
    output: gpio_d7
    id: LED1
    name: "LED"

fan:
  - platform: hbridge
    id: my_fan
    name: "petfeeder motor"
    pin_a: motor_forward_pin
    pin_b: motor_reverse_pin
    enable_pin: motor_enable
    decay_mode: slow   # slow decay mode (braking) or fast decay (coasting).

cover:
  - platform: template
    name: "Cover"
    id: my_cover
    open_action: 
      - lambda: |- 
          auto call1 = id(my_fan).turn_on();
          id(my_fan).direction = FanDirection::FORWARD; 
          call1.perform();
      - delay: 0.13s 
      - lambda: |- 
          auto call2 = id(my_fan).turn_off();
          call2.perform(); 
          id(cover_status) = 1;
      - deep_sleep.prevent: 
          id: deep_sleep_1
    close_action: 
      - lambda: |- 
          auto call1 = id(my_fan).turn_on();
          id(my_fan).direction = FanDirection::REVERSE; 
          call1.perform();
      - delay: 0.05s 
      - lambda: |- 
          auto call2 = id(my_fan).turn_off();
          call2.perform(); 
          id(cover_status) = 0;
      - deep_sleep.enter: 
          id: deep_sleep_1  

button:
  - platform: template
    name: autopetfeeder_sleep
    id: sleep_button
    on_press: 
      then:
        - lambda: |- 
            if(id(cover_status) == 1) { 
              id(my_cover).close(); 
            }      
